"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorWithCode = exports.mockResolvedEnvironment = exports.mockToolkitInfo = exports.mockBootstrapStack = exports.MockSdk = exports.MockSdkProvider = void 0;
const AWS = require("aws-sdk");
const lib_1 = require("../../lib");
const cloudformation_1 = require("../../lib/api/util/cloudformation");
const FAKE_CREDENTIALS = new AWS.Credentials({ accessKeyId: 'ACCESS', secretAccessKey: 'SECRET', sessionToken: 'TOKEN ' });
const FAKE_CREDENTIAL_CHAIN = new AWS.CredentialProviderChain([
    () => FAKE_CREDENTIALS,
]);
/**
 * An SDK that allows replacing (some of) the clients
 *
 * Its the responsibility of the consumer to replace all calls that
 * actually will be called.
 */
class MockSdkProvider extends lib_1.SdkProvider {
    constructor(options = {}) {
        var _a;
        super(FAKE_CREDENTIAL_CHAIN, 'bermuda-triangle-1337', { customUserAgent: 'aws-cdk/jest' });
        // SDK contains a real SDK, since some test use 'AWS-mock' to replace the underlying
        // AWS calls which a real SDK would do, and some tests use the 'stub' functionality below.
        if ((_a = options.realSdk) !== null && _a !== void 0 ? _a : true) {
            this.sdk = new lib_1.SDK(FAKE_CREDENTIALS, this.defaultRegion, { customUserAgent: 'aws-cdk/jest' });
        }
        else {
            this.sdk = new MockSdk();
        }
    }
    defaultAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    forEnvironment() {
        return Promise.resolve(this.sdk);
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.sdk.cloudFormation = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.sdk.ecr = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the S3 client with the given object
     */
    stubS3(stubs) {
        this.sdk.s3 = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the STS client with the given object
     */
    stubSTS(stubs) {
        this.sdk.sts = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ELBv2 client with the given object
     */
    stubELBv2(stubs) {
        this.sdk.elbv2 = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdkProvider = MockSdkProvider;
class MockSdk {
    constructor() {
        this.currentRegion = 'bermuda-triangle-1337';
        this.cloudFormation = jest.fn();
        this.ec2 = jest.fn();
        this.ssm = jest.fn();
        this.s3 = jest.fn();
        this.route53 = jest.fn();
        this.ecr = jest.fn();
        this.elbv2 = jest.fn();
    }
    currentAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.cloudFormation.mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.ecr.mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdk = MockSdk;
/**
 * Wrap synchronous fake handlers so that they sort-of function like a real AWS client
 *
 * For example, turns an object like this:
 *
 * ```ts
 * {
 *   someCall(opts: AWS.Service.SomeCallInput): AWS.Service.SomeCallOutput {
 *     return {...whatever...};
 *   }
 * }
 * ```
 *
 * Into an object that in the type system pretends to be an 'AWS.Service'
 * class (even though it really isn't) and can be called like this:
 *
 * ```ts
 * const service = await sdk.someService(...);
 * const response = await service.someCall(...).promise();
 * ```
 *
 * We only implement the narrow subset of the AWS SDK API that the CDK actually
 * uses, and we cheat on the types to make TypeScript happy on the rest of the API.
 *
 * Most important feature of this class is that it will derive the input and output
 * types of the handlers on the input object from the ACTUAL AWS Service class,
 * so that you don't have to declare them.
 */
function partialAwsService(fns) {
    // Super unsafe in here because I don't know how to make TypeScript happy,
    // but at least the outer types make sure everything that happens in here works out.
    const ret = {};
    for (const [key, handler] of Object.entries(fns)) {
        ret[key] = (args) => new FakeAWSResponse(handler(args));
    }
    return ret;
}
/**
 * Fake AWS response.
 *
 * We only ever 'await response.promise()' so that's the only thing we implement here.
 */
class FakeAWSResponse {
    constructor(x) {
        this.x = x;
    }
    promise() {
        return Promise.resolve(this.x);
    }
}
function mockBootstrapStack(sdk, stack) {
    return cloudformation_1.CloudFormationStack.fromStaticInformation((sdk !== null && sdk !== void 0 ? sdk : new MockSdk()).cloudFormation(), 'CDKToolkit', {
        CreationTime: new Date(),
        StackName: 'CDKToolkit',
        StackStatus: 'CREATE_COMPLETE',
        Outputs: [
            { OutputKey: 'BucketName', OutputValue: 'BUCKET_NAME' },
            { OutputKey: 'BucketDomainName', OutputValue: 'BUCKET_ENDPOINT' },
            { OutputKey: 'BootstrapVersion', OutputValue: '1' },
        ],
        ...stack,
    });
}
exports.mockBootstrapStack = mockBootstrapStack;
function mockToolkitInfo(stack) {
    const sdk = new MockSdk();
    return new lib_1.ToolkitInfo(mockBootstrapStack(sdk, stack), sdk);
}
exports.mockToolkitInfo = mockToolkitInfo;
function mockResolvedEnvironment() {
    return {
        account: '123456789',
        region: 'bermuda-triangle-1337',
        name: 'aws://123456789/bermuda-triangle-1337',
    };
}
exports.mockResolvedEnvironment = mockResolvedEnvironment;
function errorWithCode(code, message) {
    const ret = new Error(message);
    ret.code = code;
    return ret;
}
exports.errorWithCode = errorWithCode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1zZGsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtb2NrLXNkay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQXlFO0FBQ3pFLHNFQUF3RTtBQUV4RSxNQUFNLGdCQUFnQixHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUUzSCxNQUFNLHFCQUFxQixHQUFHLElBQUksR0FBRyxDQUFDLHVCQUF1QixDQUFDO0lBQzVELEdBQUcsRUFBRSxDQUFDLGdCQUFnQjtDQUN2QixDQUFDLENBQUM7QUFjSDs7Ozs7R0FLRztBQUNILE1BQWEsZUFBZ0IsU0FBUSxpQkFBVztJQUc5QyxZQUFZLFVBQWtDLEVBQUU7O1FBQzlDLEtBQUssQ0FBQyxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBRTNGLG9GQUFvRjtRQUNwRiwwRkFBMEY7UUFDMUYsVUFBSSxPQUFPLENBQUMsT0FBTyxtQ0FBSSxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLFNBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7U0FDL0Y7YUFBTTtZQUNMLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztTQUMxQjtJQUNILENBQUM7SUFFTSxjQUFjO1FBQ25CLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVNLGNBQWM7UUFDbkIsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FB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RUFBRSx1Q0FBdUM7S0FDOUMsQ0FBQztBQUNKLENBQUM7QUFORCwwREFNQztBQVdELFNBQWdCLGFBQWEsQ0FBQyxJQUFZLEVBQUUsT0FBZTtJQUN6RCxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM5QixHQUFXLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUN6QixPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFKRCxzQ0FJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBBY2NvdW50LCBJU0RLLCBTREssIFNka1Byb3ZpZGVyLCBUb29sa2l0SW5mbyB9IGZyb20gJy4uLy4uL2xpYic7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi4vLi4vbGliL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uJztcblxuY29uc3QgRkFLRV9DUkVERU5USUFMUyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMoeyBhY2Nlc3NLZXlJZDogJ0FDQ0VTUycsIHNlY3JldEFjY2Vzc0tleTogJ1NFQ1JFVCcsIHNlc3Npb25Ub2tlbjogJ1RPS0VOICcgfSk7XG5cbmNvbnN0IEZBS0VfQ1JFREVOVElBTF9DSEFJTiA9IG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oW1xuICAoKSA9PiBGQUtFX0NSRURFTlRJQUxTLFxuXSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9ja1Nka1Byb3ZpZGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBtb2NrIHByb3ZpZGVyIHNob3VsZCBwcm9kdWNlIGEgcmVhbCBTREtcbiAgICpcbiAgICogU29tZSB0ZXN0cyByZXF1aXJlIGEgcmVhbCBTREsgYmVjYXVzZSB0aGV5IHVzZSBgQVdTLW1vY2tgIHRvIHJlcGxhY2VcbiAgICogdGhlIHVuZGVybHlpbmcgY2FsbHMuIE90aGVyIHRlc3RzIGRvIHRoZWlyIHdvcmsgY29tcGxldGVseSB1c2luZyBqZXN0LW1vY2tzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSByZWFsU2RrPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBbiBTREsgdGhhdCBhbGxvd3MgcmVwbGFjaW5nIChzb21lIG9mKSB0aGUgY2xpZW50c1xuICpcbiAqIEl0cyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIHJlcGxhY2UgYWxsIGNhbGxzIHRoYXRcbiAqIGFjdHVhbGx5IHdpbGwgYmUgY2FsbGVkLlxuICovXG5leHBvcnQgY2xhc3MgTW9ja1Nka1Byb3ZpZGVyIGV4dGVuZHMgU2RrUHJvdmlkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBNb2NrU2RrUHJvdmlkZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihGQUtFX0NSRURFTlRJQUxfQ0hBSU4sICdiZXJtdWRhLXRyaWFuZ2xlLTEzMzcnLCB7IGN1c3RvbVVzZXJBZ2VudDogJ2F3cy1jZGsvamVzdCcgfSk7XG5cbiAgICAvLyBTREsgY29udGFpbnMgYSByZWFsIFNESywgc2luY2Ugc29tZSB0ZXN0IHVzZSAnQVdTLW1vY2snIHRvIHJlcGxhY2UgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBV1MgY2FsbHMgd2hpY2ggYSByZWFsIFNESyB3b3VsZCBkbywgYW5kIHNvbWUgdGVzdHMgdXNlIHRoZSAnc3R1YicgZnVuY3Rpb25hbGl0eSBiZWxvdy5cbiAgICBpZiAob3B0aW9ucy5yZWFsU2RrID8/IHRydWUpIHtcbiAgICAgIHRoaXMuc2RrID0gbmV3IFNESyhGQUtFX0NSRURFTlRJQUxTLCB0aGlzLmRlZmF1bHRSZWdpb24sIHsgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkay9qZXN0JyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZGsgPSBuZXcgTW9ja1NkaygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYWNjb3VudElkOiAnMTIzNDU2Nzg5MDEyJywgcGFydGl0aW9uOiAnYXdzJyB9KTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JFbnZpcm9ubWVudCgpOiBQcm9taXNlPElTREs+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBDbG91ZEZvcm1hdGlvbiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkNsb3VkRm9ybWF0aW9uKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5DbG91ZEZvcm1hdGlvbj4pIHtcbiAgICAodGhpcy5zZGsgYXMgYW55KS5jbG91ZEZvcm1hdGlvbiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkNsb3VkRm9ybWF0aW9uPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIEVDUiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkVjcihzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuRUNSPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLmVjciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkVDUj4oc3R1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBTMyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YlMzKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5TMz4pIHtcbiAgICAodGhpcy5zZGsgYXMgYW55KS5zMyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLlMzPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIFNUUyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YlNUUyhzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuU1RTPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLnN0cyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLlNUUz4oc3R1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBFTEJ2MiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkVMQnYyKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5FTEJ2Mj4pIHtcbiAgICAodGhpcy5zZGsgYXMgYW55KS5lbGJ2MiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkVMQnYyPihzdHVicykpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrU2RrIGltcGxlbWVudHMgSVNESyB7XG4gIHB1YmxpYyByZWFkb25seSBjdXJyZW50UmVnaW9uOiBzdHJpbmcgPSAnYmVybXVkYS10cmlhbmdsZS0xMzM3JztcbiAgcHVibGljIHJlYWRvbmx5IGNsb3VkRm9ybWF0aW9uID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgZWMyID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgc3NtID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgczMgPSBqZXN0LmZuKCk7XG4gIHB1YmxpYyByZWFkb25seSByb3V0ZTUzID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgZWNyID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgZWxidjIgPSBqZXN0LmZuKCk7XG5cbiAgcHVibGljIGN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8QWNjb3VudD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBhY2NvdW50SWQ6ICcxMjM0NTY3ODkwMTInLCBwYXJ0aXRpb246ICdhd3MnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIENsb3VkRm9ybWF0aW9uIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViQ2xvdWRGb3JtYXRpb24oc3R1YnM6IFN5bmNIYW5kbGVyU3Vic2V0T2Y8QVdTLkNsb3VkRm9ybWF0aW9uPikge1xuICAgIHRoaXMuY2xvdWRGb3JtYXRpb24ubW9ja1JldHVyblZhbHVlKHBhcnRpYWxBd3NTZXJ2aWNlPEFXUy5DbG91ZEZvcm1hdGlvbj4oc3R1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBFQ1IgY2xpZW50IHdpdGggdGhlIGdpdmVuIG9iamVjdFxuICAgKi9cbiAgcHVibGljIHN0dWJFY3Ioc3R1YnM6IFN5bmNIYW5kbGVyU3Vic2V0T2Y8QVdTLkVDUj4pIHtcbiAgICB0aGlzLmVjci5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkVDUj4oc3R1YnMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXAgc3luY2hyb25vdXMgZmFrZSBoYW5kbGVycyBzbyB0aGF0IHRoZXkgc29ydC1vZiBmdW5jdGlvbiBsaWtlIGEgcmVhbCBBV1MgY2xpZW50XG4gKlxuICogRm9yIGV4YW1wbGUsIHR1cm5zIGFuIG9iamVjdCBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHNcbiAqIHtcbiAqICAgc29tZUNhbGwob3B0czogQVdTLlNlcnZpY2UuU29tZUNhbGxJbnB1dCk6IEFXUy5TZXJ2aWNlLlNvbWVDYWxsT3V0cHV0IHtcbiAqICAgICByZXR1cm4gey4uLndoYXRldmVyLi4ufTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogSW50byBhbiBvYmplY3QgdGhhdCBpbiB0aGUgdHlwZSBzeXN0ZW0gcHJldGVuZHMgdG8gYmUgYW4gJ0FXUy5TZXJ2aWNlJ1xuICogY2xhc3MgKGV2ZW4gdGhvdWdoIGl0IHJlYWxseSBpc24ndCkgYW5kIGNhbiBiZSBjYWxsZWQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2RrLnNvbWVTZXJ2aWNlKC4uLik7XG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlcnZpY2Uuc29tZUNhbGwoLi4uKS5wcm9taXNlKCk7XG4gKiBgYGBcbiAqXG4gKiBXZSBvbmx5IGltcGxlbWVudCB0aGUgbmFycm93IHN1YnNldCBvZiB0aGUgQVdTIFNESyBBUEkgdGhhdCB0aGUgQ0RLIGFjdHVhbGx5XG4gKiB1c2VzLCBhbmQgd2UgY2hlYXQgb24gdGhlIHR5cGVzIHRvIG1ha2UgVHlwZVNjcmlwdCBoYXBweSBvbiB0aGUgcmVzdCBvZiB0aGUgQVBJLlxuICpcbiAqIE1vc3QgaW1wb3J0YW50IGZlYXR1cmUgb2YgdGhpcyBjbGFzcyBpcyB0aGF0IGl0IHdpbGwgZGVyaXZlIHRoZSBpbnB1dCBhbmQgb3V0cHV0XG4gKiB0eXBlcyBvZiB0aGUgaGFuZGxlcnMgb24gdGhlIGlucHV0IG9iamVjdCBmcm9tIHRoZSBBQ1RVQUwgQVdTIFNlcnZpY2UgY2xhc3MsXG4gKiBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGRlY2xhcmUgdGhlbS5cbiAqL1xuZnVuY3Rpb24gcGFydGlhbEF3c1NlcnZpY2U8Uz4oZm5zOiBTeW5jSGFuZGxlclN1YnNldE9mPFM+KTogUyB7XG4gIC8vIFN1cGVyIHVuc2FmZSBpbiBoZXJlIGJlY2F1c2UgSSBkb24ndCBrbm93IGhvdyB0byBtYWtlIFR5cGVTY3JpcHQgaGFwcHksXG4gIC8vIGJ1dCBhdCBsZWFzdCB0aGUgb3V0ZXIgdHlwZXMgbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgdGhhdCBoYXBwZW5zIGluIGhlcmUgd29ya3Mgb3V0LlxuICBjb25zdCByZXQ6IGFueSA9IHt9O1xuXG4gIGZvciAoY29uc3QgW2tleSwgaGFuZGxlcl0gb2YgT2JqZWN0LmVudHJpZXMoZm5zKSkge1xuICAgIHJldFtrZXldID0gKGFyZ3M6IGFueSkgPT4gbmV3IEZha2VBV1NSZXNwb25zZSgoaGFuZGxlciBhcyBhbnkpKGFyZ3MpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEJlY2F1c2Ugb2YgdGhlIG92ZXJsb2FkcyBhbiBBV1MgaGFuZGxlciB0eXBlIGxvb2tzIGxpa2UgdGhpczpcbi8vXG4vLyAgIHtcbi8vICAgICAgKHBhcmFtczogSU5QVVRTVFJVQ1QsIGNhbGxiYWNrPzogKChlcnI6IEFXU0Vycm9yLCBkYXRhOiB7fSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpOiBSZXF1ZXN0PE9VVFBVVCwgLi4uPjtcbi8vICAgICAgKGNhbGxiYWNrPzogKChlcnI6IEFXUy5BV1NFcnJvciwgZGF0YToge30pID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogQVdTLlJlcXVlc3Q8Li4uPjtcbi8vICAgfVxuLy9cbi8vIEdldCB0aGUgZmlyc3Qgb3ZlcmxvYWQgYW5kIGV4dHJhY3QgdGhlIGlucHV0IGFuZCBvdXRwdXQgc3RydWN0IHR5cGVzXG50eXBlIEF3c0NhbGxJbnB1dE91dHB1dDxUPiA9XG4gICAgVCBleHRlbmRzIHtcbiAgICAgIChhcmdzOiBpbmZlciBJTlBVVCwgY2FsbGJhY2s/OiAoKGVycjogQVdTLkFXU0Vycm9yLCBkYXRhOiBhbnkpID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogQVdTLlJlcXVlc3Q8aW5mZXIgT1VUUFVULCBBV1MuQVdTRXJyb3I+O1xuICAgICAgKGNhbGxiYWNrPzogKChlcnI6IEFXUy5BV1NFcnJvciwgZGF0YToge30pID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogQVdTLlJlcXVlc3Q8YW55LCBhbnk+O1xuICAgIH0gPyBbSU5QVVQsIE9VVFBVVF0gOiBUO1xuXG4vLyBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG1vY2sgaGFuZGxlciBmcm9tIHRoZSB0eXBlIG9mIHRoZSBJbnB1dC9PdXRwdXQgdHlwZSBwYWlyLlxuLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgJ25ldmVyJywgVHlwZVNjcmlwdCB3aWxsIHByb3BhZ2F0ZSBpdCB1cHdhcmRzIG1ha2luZyBpdFxuLy8gaW1wb3NzaWJsZSB0byBzcGVjaWZ5IHRoZSBmaWVsZCB0aGF0IGhhcyAnbmV2ZXInIGFueXdoZXJlIGluIGl0cyB0eXBlLlxudHlwZSBNb2NrSGFuZGxlclR5cGU8QUk+ID1cbiAgICBBSSBleHRlbmRzIFthbnksIGFueV0gPyAoaW5wdXQ6IEFJWzBdKSA9PiBBSVsxXSA6IEFJO1xuXG4vLyBBbnkgc3Vic2V0IG9mIHRoZSBmdWxsIHR5cGUgdGhhdCBzeW5jaHJvbm91c2x5IHJldHVybnMgdGhlIG91dHB1dCBzdHJ1Y3R1cmUgaXMgb2theVxuZXhwb3J0IHR5cGUgU3luY0hhbmRsZXJTdWJzZXRPZjxTPiA9IHtbSyBpbiBrZXlvZiBTXT86IE1vY2tIYW5kbGVyVHlwZTxBd3NDYWxsSW5wdXRPdXRwdXQ8U1tLXT4+fTtcblxuLyoqXG4gKiBGYWtlIEFXUyByZXNwb25zZS5cbiAqXG4gKiBXZSBvbmx5IGV2ZXIgJ2F3YWl0IHJlc3BvbnNlLnByb21pc2UoKScgc28gdGhhdCdzIHRoZSBvbmx5IHRoaW5nIHdlIGltcGxlbWVudCBoZXJlLlxuICovXG5jbGFzcyBGYWtlQVdTUmVzcG9uc2U8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHg6IFQpIHtcbiAgfVxuXG4gIHB1YmxpYyBwcm9taXNlKCk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy54KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ja0Jvb3RzdHJhcFN0YWNrKHNkazogSVNESyB8IHVuZGVmaW5lZCwgc3RhY2s/OiBQYXJ0aWFsPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFjaz4pIHtcbiAgcmV0dXJuIENsb3VkRm9ybWF0aW9uU3RhY2suZnJvbVN0YXRpY0luZm9ybWF0aW9uKChzZGsgPz8gbmV3IE1vY2tTZGsoKSkuY2xvdWRGb3JtYXRpb24oKSwgJ0NES1Rvb2xraXQnLCB7XG4gICAgQ3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLFxuICAgIFN0YWNrTmFtZTogJ0NES1Rvb2xraXQnLFxuICAgIFN0YWNrU3RhdHVzOiAnQ1JFQVRFX0NPTVBMRVRFJyxcbiAgICBPdXRwdXRzOiBbXG4gICAgICB7IE91dHB1dEtleTogJ0J1Y2tldE5hbWUnLCBPdXRwdXRWYWx1ZTogJ0JVQ0tFVF9OQU1FJyB9LFxuICAgICAgeyBPdXRwdXRLZXk6ICdCdWNrZXREb21haW5OYW1lJywgT3V0cHV0VmFsdWU6ICdCVUNLRVRfRU5EUE9JTlQnIH0sXG4gICAgICB7IE91dHB1dEtleTogJ0Jvb3RzdHJhcFZlcnNpb24nLCBPdXRwdXRWYWx1ZTogJzEnIH0sXG4gICAgXSxcbiAgICAuLi5zdGFjayxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrVG9vbGtpdEluZm8oc3RhY2s/OiBQYXJ0aWFsPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFjaz4pIHtcbiAgY29uc3Qgc2RrID0gbmV3IE1vY2tTZGsoKTtcbiAgcmV0dXJuIG5ldyBUb29sa2l0SW5mbyhtb2NrQm9vdHN0cmFwU3RhY2soc2RrLCBzdGFjayksIHNkayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrUmVzb2x2ZWRFbnZpcm9ubWVudCgpOiBjeGFwaS5FbnZpcm9ubWVudCB7XG4gIHJldHVybiB7XG4gICAgYWNjb3VudDogJzEyMzQ1Njc4OScsXG4gICAgcmVnaW9uOiAnYmVybXVkYS10cmlhbmdsZS0xMzM3JyxcbiAgICBuYW1lOiAnYXdzOi8vMTIzNDU2Nzg5L2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycsXG4gIH07XG59XG5cbi8vIEplc3QgaGVscGVyc1xuXG4vLyBBbiBvYmplY3Qgb24gd2hpY2ggYWxsIGNhbGxhYmxlcyBhcmUgSmVzdCBNb2Nrc1xuZXhwb3J0IHR5cGUgTW9ja2VkT2JqZWN0PFMgZXh0ZW5kcyBvYmplY3Q+ID0ge1tLIGluIGtleW9mIFNdOiBNb2NrZWRGdW5jdGlvbjxSZXF1aXJlZDxTPltLXT59O1xuXG4vLyBJZiBhIGZ1bmN0aW9uLCB0aGVuIGEgbW9ja2VkIHZlcnNpb24gb2YgaXQsIG90aGVyd2lzZSBqdXN0IFRcbnR5cGUgTW9ja2VkRnVuY3Rpb248VD4gPSBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnlcbiAgPyBqZXN0Lk1vY2tJbnN0YW5jZTxSZXR1cm5UeXBlPFQ+LCBqZXN0LkFyZ3NUeXBlPFQ+PlxuICA6IFQ7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JXaXRoQ29kZShjb2RlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCByZXQgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIChyZXQgYXMgYW55KS5jb2RlID0gY29kZTtcbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==