"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bootstrapVersionFromTemplate = exports.BootstrapStack = void 0;
const os = require("os");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const aws_auth_1 = require("../aws-auth");
const deploy_stack_1 = require("../deploy-stack");
const toolkit_info_1 = require("../toolkit-info");
const bootstrap_props_1 = require("./bootstrap-props");
/**
 * A class to hold state around stack bootstrapping
 *
 * This class exists so we can break bootstrapping into 2 phases:
 *
 * ```ts
 * const current = BootstrapStack.lookup(...);
 * // ...
 * current.update(newTemplate, ...);
 * ```
 *
 * And do something in between the two phases (such as look at the
 * current bootstrap stack and doing something intelligent).
 *
 * This class is different from `ToolkitInfo` in that `ToolkitInfo`
 * is purely read-only, and `ToolkitInfo.lookup()` returns `undefined`
 * if the stack does not exist. But honestly, these classes could and
 * should probably be merged at some point.
 */
class BootstrapStack {
    constructor(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo) {
        this.sdkProvider = sdkProvider;
        this.sdk = sdk;
        this.resolvedEnvironment = resolvedEnvironment;
        this.toolkitStackName = toolkitStackName;
        this.currentToolkitInfo = currentToolkitInfo;
    }
    static async lookup(sdkProvider, environment, toolkitStackName) {
        toolkitStackName = toolkitStackName !== null && toolkitStackName !== void 0 ? toolkitStackName : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const resolvedEnvironment = await sdkProvider.resolveEnvironment(environment);
        const sdk = await sdkProvider.forEnvironment(resolvedEnvironment, aws_auth_1.Mode.ForWriting);
        const currentToolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(resolvedEnvironment, sdk, toolkitStackName);
        return new BootstrapStack(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo);
    }
    get parameters() {
        var _a, _b;
        return (_b = (_a = this.currentToolkitInfo) === null || _a === void 0 ? void 0 : _a.parameters) !== null && _b !== void 0 ? _b : {};
    }
    get terminationProtection() {
        var _a, _b;
        return (_b = (_a = this.currentToolkitInfo) === null || _a === void 0 ? void 0 : _a.stack) === null || _b === void 0 ? void 0 : _b.terminationProtection;
    }
    async partition() {
        return (await this.sdk.currentAccount()).partition;
    }
    /**
     * Perform the actual deployment of a bootstrap stack, given a template and some parameters
     */
    async update(template, parameters, options) {
        var _a;
        const newVersion = bootstrapVersionFromTemplate(template);
        if (this.currentToolkitInfo && newVersion < this.currentToolkitInfo.version && !options.force) {
            throw new Error(`Not downgrading existing bootstrap stack from version '${this.currentToolkitInfo.version}' to version '${newVersion}'. Use --force to force.`);
        }
        const outdir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-bootstrap'));
        const builder = new cxapi.CloudAssemblyBuilder(outdir);
        const templateFile = `${this.toolkitStackName}.template.json`;
        await fs.writeJson(path.join(builder.outdir, templateFile), template, { spaces: 2 });
        builder.addArtifact(this.toolkitStackName, {
            type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: cxapi.EnvironmentUtils.format(this.resolvedEnvironment.account, this.resolvedEnvironment.region),
            properties: {
                templateFile,
                terminationProtection: (_a = options.terminationProtection) !== null && _a !== void 0 ? _a : false,
            },
        });
        const assembly = builder.buildAssembly();
        return deploy_stack_1.deployStack({
            stack: assembly.getStackByName(this.toolkitStackName),
            resolvedEnvironment: this.resolvedEnvironment,
            sdk: this.sdk,
            sdkProvider: this.sdkProvider,
            force: options.force,
            roleArn: options.roleArn,
            tags: options.tags,
            execute: options.execute,
            parameters,
            usePreviousParameters: true,
        });
    }
}
exports.BootstrapStack = BootstrapStack;
function bootstrapVersionFromTemplate(template) {
    var _a, _b, _c, _d, _e;
    const versionSources = [
        (_b = (_a = template.Outputs) === null || _a === void 0 ? void 0 : _a[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT]) === null || _b === void 0 ? void 0 : _b.Value,
        (_e = (_d = (_c = template.Resources) === null || _c === void 0 ? void 0 : _c[bootstrap_props_1.BOOTSTRAP_VERSION_RESOURCE]) === null || _d === void 0 ? void 0 : _d.Properties) === null || _e === void 0 ? void 0 : _e.Value,
    ];
    for (const vs of versionSources) {
        if (typeof vs === 'number') {
            return vs;
        }
        if (typeof vs === 'string' && !isNaN(parseInt(vs, 10))) {
            return parseInt(vs, 10);
        }
    }
    return 0;
}
exports.bootstrapVersionFromTemplate = bootstrapVersionFromTemplate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LWJvb3RzdHJhcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcGxveS1ib290c3RyYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQiwwQ0FBc0Q7QUFDdEQsa0RBQWlFO0FBQ2pFLGtEQUEwRTtBQUMxRSx1REFBc0g7QUFFdEg7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILE1BQWEsY0FBYztJQVd6QixZQUNtQixXQUF3QixFQUN4QixHQUFTLEVBQ1QsbUJBQXNDLEVBQ3RDLGdCQUF3QixFQUN4QixrQkFBZ0M7UUFKaEMsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsUUFBRyxHQUFILEdBQUcsQ0FBTTtRQUNULHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBbUI7UUFDdEMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFRO1FBQ3hCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBYztJQUNuRCxDQUFDO0lBaEJNLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQXdCLEVBQUUsV0FBOEIsRUFBRSxnQkFBeUI7UUFDNUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLGFBQWhCLGdCQUFnQixjQUFoQixnQkFBZ0IsR0FBSSx5Q0FBMEIsQ0FBQztRQUVsRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sV0FBVyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlFLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsRUFBRSxlQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbkYsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLDBCQUFXLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRWhHLE9BQU8sSUFBSSxjQUFjLENBQUMsV0FB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MENBQUcsMENBQXdCLDJDQUFHLEtBQUs7MEJBQ25ELFFBQVEsQ0FBQyxTQUFTLDBDQUFHLDRDQUEwQiwyQ0FBRyxVQUFVLDBDQUFFLEtBQUs7S0FDcEUsQ0FBQztJQUVGLEtBQUssTUFBTSxFQUFFLElBQUksY0FBYyxFQUFFO1FBQy9CLElBQUksT0FBTyxFQUFFLEtBQUssUUFBUSxFQUFFO1lBQUUsT0FBTyxFQUFFLENBQUM7U0FBRTtRQUMxQyxJQUFJLE9BQU8sRUFBRSxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUU7WUFDdEQsT0FBTyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3pCO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFiRCxvRUFhQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IE1vZGUsIFNka1Byb3ZpZGVyLCBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgZGVwbG95U3RhY2ssIERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FLCBUb29sa2l0SW5mbyB9IGZyb20gJy4uL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsIEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucywgQk9PVFNUUkFQX1ZFUlNJT05fUkVTT1VSQ0UgfSBmcm9tICcuL2Jvb3RzdHJhcC1wcm9wcyc7XG5cbi8qKlxuICogQSBjbGFzcyB0byBob2xkIHN0YXRlIGFyb3VuZCBzdGFjayBib290c3RyYXBwaW5nXG4gKlxuICogVGhpcyBjbGFzcyBleGlzdHMgc28gd2UgY2FuIGJyZWFrIGJvb3RzdHJhcHBpbmcgaW50byAyIHBoYXNlczpcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgY3VycmVudCA9IEJvb3RzdHJhcFN0YWNrLmxvb2t1cCguLi4pO1xuICogLy8gLi4uXG4gKiBjdXJyZW50LnVwZGF0ZShuZXdUZW1wbGF0ZSwgLi4uKTtcbiAqIGBgYFxuICpcbiAqIEFuZCBkbyBzb21ldGhpbmcgaW4gYmV0d2VlbiB0aGUgdHdvIHBoYXNlcyAoc3VjaCBhcyBsb29rIGF0IHRoZVxuICogY3VycmVudCBib290c3RyYXAgc3RhY2sgYW5kIGRvaW5nIHNvbWV0aGluZyBpbnRlbGxpZ2VudCkuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBkaWZmZXJlbnQgZnJvbSBgVG9vbGtpdEluZm9gIGluIHRoYXQgYFRvb2xraXRJbmZvYFxuICogaXMgcHVyZWx5IHJlYWQtb25seSwgYW5kIGBUb29sa2l0SW5mby5sb29rdXAoKWAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICogaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LiBCdXQgaG9uZXN0bHksIHRoZXNlIGNsYXNzZXMgY291bGQgYW5kXG4gKiBzaG91bGQgcHJvYmFibHkgYmUgbWVyZ2VkIGF0IHNvbWUgcG9pbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBTdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nKSB7XG4gICAgdG9vbGtpdFN0YWNrTmFtZSA9IHRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG5cbiAgICBjb25zdCByZXNvbHZlZEVudmlyb25tZW50ID0gYXdhaXQgc2RrUHJvdmlkZXIucmVzb2x2ZUVudmlyb25tZW50KGVudmlyb25tZW50KTtcbiAgICBjb25zdCBzZGsgPSBhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudmlyb25tZW50LCBNb2RlLkZvcldyaXRpbmcpO1xuICAgIGNvbnN0IGN1cnJlbnRUb29sa2l0SW5mbyA9IGF3YWl0IFRvb2xraXRJbmZvLmxvb2t1cChyZXNvbHZlZEVudmlyb25tZW50LCBzZGssIHRvb2xraXRTdGFja05hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFjayhzZGtQcm92aWRlciwgc2RrLCByZXNvbHZlZEVudmlyb25tZW50LCB0b29sa2l0U3RhY2tOYW1lLCBjdXJyZW50VG9vbGtpdEluZm8pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjdXJyZW50VG9vbGtpdEluZm8/OiBUb29sa2l0SW5mbykge1xuICB9XG5cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUb29sa2l0SW5mbz8ucGFyYW1ldGVycyA/PyB7fTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUb29sa2l0SW5mbz8uc3RhY2s/LnRlcm1pbmF0aW9uUHJvdGVjdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwYXJ0aXRpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuc2RrLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgZGVwbG95bWVudCBvZiBhIGJvb3RzdHJhcCBzdGFjaywgZ2l2ZW4gYSB0ZW1wbGF0ZSBhbmQgc29tZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdXBkYXRlKFxuICAgIHRlbXBsYXRlOiBhbnksXG4gICAgcGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBvcHRpb25zOiBPbWl0PEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucywgJ3BhcmFtZXRlcnMnPixcbiAgKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuXG4gICAgY29uc3QgbmV3VmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRUb29sa2l0SW5mbyAmJiBuZXdWZXJzaW9uIDwgdGhpcy5jdXJyZW50VG9vbGtpdEluZm8udmVyc2lvbiAmJiAhb3B0aW9ucy5mb3JjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZG93bmdyYWRpbmcgZXhpc3RpbmcgYm9vdHN0cmFwIHN0YWNrIGZyb20gdmVyc2lvbiAnJHt0aGlzLmN1cnJlbnRUb29sa2l0SW5mby52ZXJzaW9ufScgdG8gdmVyc2lvbiAnJHtuZXdWZXJzaW9ufScuIFVzZSAtLWZvcmNlIHRvIGZvcmNlLmApO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGRpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWJvb3RzdHJhcCcpKTtcbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHlCdWlsZGVyKG91dGRpcik7XG4gICAgY29uc3QgdGVtcGxhdGVGaWxlID0gYCR7dGhpcy50b29sa2l0U3RhY2tOYW1lfS50ZW1wbGF0ZS5qc29uYDtcbiAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5qb2luKGJ1aWxkZXIub3V0ZGlyLCB0ZW1wbGF0ZUZpbGUpLCB0ZW1wbGF0ZSwgeyBzcGFjZXM6IDIgfSk7XG5cbiAgICBidWlsZGVyLmFkZEFydGlmYWN0KHRoaXMudG9vbGtpdFN0YWNrTmFtZSwge1xuICAgICAgdHlwZTogY3hzY2hlbWEuQXJ0aWZhY3RUeXBlLkFXU19DTE9VREZPUk1BVElPTl9TVEFDSyxcbiAgICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudFV0aWxzLmZvcm1hdCh0aGlzLnJlc29sdmVkRW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5yZXNvbHZlZEVudmlyb25tZW50LnJlZ2lvbiksXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRlbXBsYXRlRmlsZSxcbiAgICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBvcHRpb25zLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBhc3NlbWJseSA9IGJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xuXG4gICAgcmV0dXJuIGRlcGxveVN0YWNrKHtcbiAgICAgIHN0YWNrOiBhc3NlbWJseS5nZXRTdGFja0J5TmFtZSh0aGlzLnRvb2xraXRTdGFja05hbWUpLFxuICAgICAgcmVzb2x2ZWRFbnZpcm9ubWVudDogdGhpcy5yZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgc2RrOiB0aGlzLnNkayxcbiAgICAgIHNka1Byb3ZpZGVyOiB0aGlzLnNka1Byb3ZpZGVyLFxuICAgICAgZm9yY2U6IG9wdGlvbnMuZm9yY2UsXG4gICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICB0YWdzOiBvcHRpb25zLnRhZ3MsXG4gICAgICBleGVjdXRlOiBvcHRpb25zLmV4ZWN1dGUsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib290c3RyYXBWZXJzaW9uRnJvbVRlbXBsYXRlKHRlbXBsYXRlOiBhbnkpOiBudW1iZXIge1xuICBjb25zdCB2ZXJzaW9uU291cmNlcyA9IFtcbiAgICB0ZW1wbGF0ZS5PdXRwdXRzPy5bQk9PVFNUUkFQX1ZFUlNJT05fT1VUUFVUXT8uVmFsdWUsXG4gICAgdGVtcGxhdGUuUmVzb3VyY2VzPy5bQk9PVFNUUkFQX1ZFUlNJT05fUkVTT1VSQ0VdPy5Qcm9wZXJ0aWVzPy5WYWx1ZSxcbiAgXTtcblxuICBmb3IgKGNvbnN0IHZzIG9mIHZlcnNpb25Tb3VyY2VzKSB7XG4gICAgaWYgKHR5cGVvZiB2cyA9PT0gJ251bWJlcicpIHsgcmV0dXJuIHZzOyB9XG4gICAgaWYgKHR5cGVvZiB2cyA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKHBhcnNlSW50KHZzLCAxMCkpKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodnMsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59Il19