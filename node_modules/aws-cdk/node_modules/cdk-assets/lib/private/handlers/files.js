"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverCurrentAccount())) === null || _a === void 0 ? void 0 : _a.accountId; };
        switch (await bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        await s3.upload({
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: fs_1.createReadStream(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }).promise();
    }
    async packageFile(source) {
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await fs_extra_1.pathExists(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${path}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${path}`);
            await archive_1.zipDirectory(fullPath, packagedPath);
            return { packagedPath, contentType };
        }
        else {
            return { packagedPath: fullPath };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await shell_1.shell(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function bucketOwnership(s3, bucket) {
    try {
        await s3.getBucketLocation({ Bucket: bucket }).promise();
        return BucketOwnership.MINE;
    }
    catch (e) {
        if (e.code === 'NoSuchBucket') {
            return BucketOwnership.DOES_NOT_EXIST;
        }
        if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
            return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
        }
        throw e;
    }
}
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return response.Contents != null && response.Contents.some(object => object.Key === key);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUVoRiw2Q0FBMkM7QUFDM0Msd0NBQTBDO0FBRTFDLDBDQUF5QztBQUN6QyxrREFBeUQ7QUFDekQsb0NBQWlDO0FBRWpDLE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLE9BQWUsRUFDZixLQUF3QixFQUN4QixJQUFrQjtRQUZsQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2YsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFDeEIsU0FBSSxHQUFKLElBQUksQ0FBYztRQUNuQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTSxLQUFLLENBQUMsT0FBTztRQUNsQixNQUFNLFdBQVcsR0FBRyxNQUFNLHFDQUFzQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEYsTUFBTSxLQUFLLEdBQUcsUUFBUSxXQUFXLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUV4RSxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLEtBQUssRUFBRSxTQUFTLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFekQsbUZBQW1GO1FBQ25GLG9DQUFvQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxLQUFLLElBQUksRUFBRSx3QkFBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyww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U0FBRTtRQUN6RSxJQUFJLENBQUMsY0FBYyxFQUFFLG1CQUFtQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUFFLE9BQU8sZUFBZSxDQUFDLDBCQUEwQixDQUFDO1NBQUU7UUFDbEgsTUFBTSxDQUFDLENBQUM7S0FDVDtBQUNILENBQUM7QUFFRCxLQUFLLFVBQVUsWUFBWSxDQUFDLEVBQVUsRUFBRSxNQUFjLEVBQUUsR0FBVztJQUNqRTs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQy9GLE9BQU8sUUFBUSxDQUFDLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQzNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHsgRmlsZU1hbmlmZXN0RW50cnkgfSBmcm9tICcuLi8uLi9hc3NldC1tYW5pZmVzdCc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9wcm9ncmVzcyc7XG5pbXBvcnQgeyB6aXBEaXJlY3RvcnkgfSBmcm9tICcuLi9hcmNoaXZlJztcbmltcG9ydCB7IElBc3NldEhhbmRsZXIsIElIYW5kbGVySG9zdCB9IGZyb20gJy4uL2Fzc2V0LWhhbmRsZXInO1xuaW1wb3J0IHsgcGF0aEV4aXN0cyB9IGZyb20gJy4uL2ZzLWV4dHJhJztcbmltcG9ydCB7IHJlcGxhY2VBd3NQbGFjZWhvbGRlcnMgfSBmcm9tICcuLi9wbGFjZWhvbGRlcnMnO1xuaW1wb3J0IHsgc2hlbGwgfSBmcm9tICcuLi9zaGVsbCc7XG5cbmV4cG9ydCBjbGFzcyBGaWxlQXNzZXRIYW5kbGVyIGltcGxlbWVudHMgSUFzc2V0SGFuZGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZUNhY2hlUm9vdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya0Rpcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZXQ6IEZpbGVNYW5pZmVzdEVudHJ5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogSUhhbmRsZXJIb3N0KSB7XG4gICAgdGhpcy5maWxlQ2FjaGVSb290ID0gcGF0aC5qb2luKHdvcmtEaXIsICcuY2FjaGUnKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWJsaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcblxuICAgIGNvbnN0IHMzID0gYXdhaXQgdGhpcy5ob3N0LmF3cy5zM0NsaWVudChkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DSEVDSywgYENoZWNrICR7czNVcmx9YCk7XG5cbiAgICAvLyBBIHRodW5rIGZvciBkZXNjcmliaW5nIHRoZSBjdXJyZW50IGFjY291bnQuIFVzZWQgd2hlbiB3ZSBuZWVkIHRvIGZvcm1hdCBhbiBlcnJvclxuICAgIC8vIG1lc3NhZ2UsIG5vdCBpbiB0aGUgc3VjY2VzcyBjYXNlLlxuICAgIGNvbnN0IGFjY291bnQgPSBhc3luYyAoKSA9PiAoYXdhaXQgdGhpcy5ob3N0LmF3cy5kaXNjb3ZlckN1cnJlbnRBY2NvdW50KCkpPy5hY2NvdW50SWQ7XG4gICAgc3dpdGNoIChhd2FpdCBidWNrZXRPd25lcnNoaXAoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUpKSB7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5NSU5FOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIElzIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9IGJvb3RzdHJhcHBlZD9gKTtcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScgZXhpc3RzLCBidXQgbm90IGluIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9LiBXcm9uZyBhY2NvdW50P2ApO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBvYmplY3RFeGlzdHMoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsIGRlc3RpbmF0aW9uLm9iamVjdEtleSkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke3MzVXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm47IH1cbiAgICBjb25zdCBwdWJsaXNoRmlsZSA9IHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUgP1xuICAgICAgYXdhaXQgdGhpcy5leHRlcm5hbFBhY2thZ2VGaWxlKHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpIDogYXdhaXQgdGhpcy5wYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZSk7XG5cbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLlVQTE9BRCwgYFVwbG9hZCAke3MzVXJsfWApO1xuICAgIGF3YWl0IHMzLnVwbG9hZCh7XG4gICAgICBCdWNrZXQ6IGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICBLZXk6IGRlc3RpbmF0aW9uLm9iamVjdEtleSxcbiAgICAgIEJvZHk6IGNyZWF0ZVJlYWRTdHJlYW0ocHVibGlzaEZpbGUucGFja2FnZWRQYXRoKSxcbiAgICAgIENvbnRlbnRUeXBlOiBwdWJsaXNoRmlsZS5jb250ZW50VHlwZSxcbiAgICB9KS5wcm9taXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdwYXRoJyBpcyBleHBlY3RlZCBpbiB0aGUgRmlsZSBhc3NldCBzb3VyY2UsIGdvdDogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLnBhdGgpO1xuXG4gICAgaWYgKHNvdXJjZS5wYWNrYWdpbmcgPT09IEZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgICBhd2FpdCBmcy5ta2Rpcih0aGlzLmZpbGVDYWNoZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFja2FnZWRQYXRoID0gcGF0aC5qb2luKHRoaXMuZmlsZUNhY2hlUm9vdCwgYCR7dGhpcy5hc3NldC5pZC5hc3NldElkfS56aXBgKTtcblxuICAgICAgaWYgKGF3YWl0IHBhdGhFeGlzdHMocGFja2FnZWRQYXRoKSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYEZyb20gY2FjaGUgJHtwYXRofWApO1xuICAgICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBaaXAgJHtmdWxsUGF0aH0gLT4gJHtwYXRofWApO1xuICAgICAgYXdhaXQgemlwRGlyZWN0b3J5KGZ1bGxQYXRoLCBwYWNrYWdlZFBhdGgpO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGg6IGZ1bGxQYXRoIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBleHRlcm5hbFBhY2thZ2VGaWxlKGV4ZWN1dGFibGU6IHN0cmluZ1tdKTogUHJvbWlzZTxQYWNrYWdlZEZpbGVBc3NldD4ge1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBCdWlsZGluZyBhc3NldCBzb3VyY2UgdXNpbmcgY29tbWFuZDogJyR7ZXhlY3V0YWJsZX0nYCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFja2FnZWRQYXRoOiAoYXdhaXQgc2hlbGwoZXhlY3V0YWJsZSwgeyBxdWlldDogdHJ1ZSB9KSkudHJpbSgpLFxuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgIH07XG4gIH1cbn1cblxuZW51bSBCdWNrZXRPd25lcnNoaXAge1xuICBET0VTX05PVF9FWElTVCxcbiAgTUlORSxcbiAgU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1Ncbn1cblxuYXN5bmMgZnVuY3Rpb24gYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzMy5nZXRCdWNrZXRMb2NhdGlvbih7IEJ1Y2tldDogYnVja2V0IH0pLnByb21pc2UoKTtcbiAgICByZXR1cm4gQnVja2V0T3duZXJzaGlwLk1JTkU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnTm9TdWNoQnVja2V0JykgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOyB9XG4gICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOyB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBvYmplY3RFeGlzdHMoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcsIGtleTogc3RyaW5nKSB7XG4gIC8qXG4gICAqIFRoZSBvYmplY3QgZXhpc3RlbmNlIGNoZWNrIGhlcmUgcmVmcmFpbnMgZnJvbSB1c2luZyB0aGUgYGhlYWRPYmplY3RgIG9wZXJhdGlvbiBiZWNhdXNlIHRoaXNcbiAgICogd291bGQgY3JlYXRlIGEgbmVnYXRpdmUgY2FjaGUgZW50cnksIG1ha2luZyBHRVQtYWZ0ZXItUFVUIGV2ZW50dWFsbHkgY29uc2lzdGVudC4gVGhpcyBoYXMgYmVlblxuICAgKiBvYnNlcnZlZCB0byByZXN1bHQgaW4gQ2xvdWRGb3JtYXRpb24gaXNzdWluZyBcIlZhbGlkYXRpb25FcnJvcjogUzMgZXJyb3I6IEFjY2VzcyBEZW5pZWRcIiwgZm9yXG4gICAqIGV4YW1wbGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy82NDMwLlxuICAgKlxuICAgKiBUbyBwcmV2ZW50IHRoaXMsIHdlIGFyZSBpbnN0ZWFkIHVzaW5nIHRoZSBsaXN0T2JqZWN0c1YyIGNhbGwsIHVzaW5nIHRoZSBsb29rZWQgdXAga2V5IGFzIHRoZVxuICAgKiBwcmVmaXgsIGFuZCBsaW1pdGluZyByZXN1bHRzIHRvIDEuIFNpbmNlIHRoZSBsaXN0IG9wZXJhdGlvbiByZXR1cm5zIGtleXMgb3JkZXJlZCBieSBiaW5hcnlcbiAgICogVVRGLTggcmVwcmVzZW50YXRpb24sIHRoZSBrZXkgd2UgYXJlIGxvb2tpbmcgZm9yIGlzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBtYXRjaFxuICAgKiByZXR1cm5lZCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHMzLmxpc3RPYmplY3RzVjIoeyBCdWNrZXQ6IGJ1Y2tldCwgUHJlZml4OiBrZXksIE1heEtleXM6IDEgfSkucHJvbWlzZSgpO1xuICByZXR1cm4gcmVzcG9uc2UuQ29udGVudHMgIT0gbnVsbCAmJiByZXNwb25zZS5Db250ZW50cy5zb21lKG9iamVjdCA9PiBvYmplY3QuS2V5ID09PSBrZXkpO1xufVxuXG5cbi8qKlxuICogQSBwYWNrYWdlZCBhc3NldCB3aGljaCBjYW4gYmUgdXBsb2FkZWQgKGVpdGhlciBhIHNpbmdsZSBmaWxlIG9yIGRpcmVjdG9yeSlcbiAqL1xuaW50ZXJmYWNlIFBhY2thZ2VkRmlsZUFzc2V0IHtcbiAgLyoqXG4gICAqIFBhdGggb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlZFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogQ29udGVudCB0eXBlIHRvIGJlIGFkZGVkIGluIHRoZSBTMyB1cGxvYWQgYWN0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gY29udGVudCB0eXBlXG4gICAqL1xuICByZWFkb25seSBjb250ZW50VHlwZT86IHN0cmluZztcbn1cbiJdfQ==